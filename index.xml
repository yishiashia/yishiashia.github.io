<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>yishiashia&#39;s Blog</title>
    <link>https://yishiashia.github.io/</link>
    <description>Recent content on yishiashia&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-TW</language>
    <lastBuildDate>Wed, 15 Nov 2023 16:06:55 +0800</lastBuildDate><atom:link href="https://yishiashia.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>嗨！你好 👋</title>
      <link>https://yishiashia.github.io/posts/hello-world/</link>
      <pubDate>Wed, 15 Nov 2023 16:06:55 +0800</pubDate>
      
      <guid>https://yishiashia.github.io/posts/hello-world/</guid>
      <description>我是yishiashia，這邊會分享我在工作上的所遇到的問題與學習心得，請多多指教！</description>
    </item>
    
    <item>
      <title>使用 WebAuthn 實作無密碼驗證與 Passkeys 介紹</title>
      <link>https://yishiashia.github.io/posts/passkey-and-webauthn-passwordless-authentication/</link>
      <pubDate>Tue, 15 Nov 2022 16:22:57 +0800</pubDate>
      
      <guid>https://yishiashia.github.io/posts/passkey-and-webauthn-passwordless-authentication/</guid>
      <description>Google、Apple、微軟及數百間科技公司或服務商在今年 (2022) 不約而同的表態支持 FIDO 聯盟與 W3C 所主推的通用無密碼登入標準 (common passwordless sign-in standard)，希望能透過例如指紋、Face ID等認證手段替代原本的密碼登入機制，提供用戶在網頁登入時一個更安全、防網路釣魚、即時交易驗證的登入方式。
Google 在今年10月上旬宣布在 Android 及 Chrome 導入 Passkeys 無密碼認證機制，而 Apple 也將在 iOS 16 和 macOS Ventura 引入 Passkeys ，透過掃描 QR Code 加上藍芽或其他裝置通訊技術，讓你可以透過手機的 Touch ID 或 Face ID 就可以登入你所有的電腦、平板等裝置。
下面我們會先說明需要使用密碼跟無密碼認證使用的場景，再深入介紹實務上使用 FIDO2 進行註冊與認證 (含範例程式)，最後再總結 FIDO2 / WebAuthn 與 Passkeys 的關係 。
Photo by regularguy.eth on Unsplash
通常需要用到 ”密碼” 或 ”認證” 的場合，像是在電商網站買東西、下訂單最後要結帳的時候會請你輸入帳號、密碼做登入(不登入的話也可能會要求你透過手機簡訊驗證碼做實名制驗證)，可以用以確保您在真實世界的身分。
在資訊安全的領域中，不管是帳號密碼或是手機簡訊驗證碼的驗證，都是屬於 挑戰回應(Challenge/Response) 的方法。
挑戰回應 的方法具體來說，是指由正在溝通的兩方其中之一發起一個 挑戰 (Challenge)，而另一方提供一個正確可被驗證的合法答案 (Response)。
最常見的使用情境就是使用密碼驗證，比方說在電商網站購物前送出訂單之前請買家在網頁上再輸入一次密碼，如果密碼正確 (Valid response) ，則可以確認是由本人進行的操作。</description>
    </item>
    
    <item>
      <title>簡易密碼學介紹</title>
      <link>https://yishiashia.github.io/posts/introduction-to-basic-cryptography/</link>
      <pubDate>Mon, 07 Nov 2022 16:12:47 +0800</pubDate>
      
      <guid>https://yishiashia.github.io/posts/introduction-to-basic-cryptography/</guid>
      <description>在早期，密碼學(Cryptography)是泛指隱藏訊息(hiding information)的方法，背後相關的知識包含數學、電腦科學(Computer science)及工程學等等，但時至今日，密碼學除了隱藏訊息之外，也同樣注重資訊安全屬性中的資訊完整性與不可抵賴性。
資訊完整性可透過驗算訊息驗證碼(如雜湊值或 checksum 等)來確認訊息沒有被人竄改過，而不可抵賴性則可以透過數位簽章的方式來驗證，下面來詳細說明。
Photo by Towfiqu barbhuiya on Unsplash
加密演算法介紹 加密演算法是指訊息交換的雙方透過約定的密鑰(key)對訊息加密，原始的訊息(明文，plaintext)經過加密後會變成密文(cyphertext)，密文只有透過密鑰才可以還原回可閱讀的明文，因此可以放心透過網路或其他方式進行傳輸。
根據密鑰的特性一般可分作 對稱式加密演算法 及 非對稱式加密演算法，非對稱式加密演算法是指訊息傳遞者會產生一對 公鑰(public key) 及 私鑰(private key)。
1. 對稱式加密演算法 訊息交換雙方共享一組密鑰(key)，這密鑰就相當於兩人共享的秘密(shared secret)，沒有第三者知道。
當訊息要由A君傳送給B君時，A君會使用共享的密鑰對訊息進行加密，然後將加密後的密文傳遞給B君，B君再透過兩人共享的密鑰對密文進行解密，就可以取得明文的內容。
目前常見的對稱式加密演算法有一般網頁瀏覽時SSL/TLS加密使用的AES加密演算法，在 SSL/TLS handshake 時，瀏覽器跟網站伺服器間會協商出一個本次瀏覽期間使用的共享密鑰，在這次瀏覽期間使用的網頁封包都會透過這組密鑰進行加密。
2. 非對稱式加密演算法 明文透過公鑰加密變成密文後，需要透過對應的私鑰進行解密才能還原回明文；相反的，如果明文是透過私鑰進行加密變成密文，則需要透過對應的公鑰進行解密才能還原成明文。
圖片來源: 維基百科
而公私鑰的保存依照字面上的意思，私鑰需要由訊息傳遞者自己保存好，不能被別人知道(用以確保訊息是本人發送)，而公鑰顧名思義則是需要公開給所有人知道，一般的應用會透過可信任的第三方來保管所有訊息傳遞者的公鑰，比如政府的自然人憑證或健保卡憑證都是由政府建置所謂的公開金鑰基礎建設 (英語：Public Key Infrastructure，縮寫：PKI)，透過 PKI ，我們就可以取得使用者的的公鑰來解密訊息。
而上面我們提到非對稱式加密演算法的加解密特性與公私鑰的保管性質，就可以進行 數位簽章(確保是本人) 與 訊息保密 的動作。
數位簽章： 透過私鑰對訊息進行加密後傳送，所有人都可以透過在PKI取得訊息傳遞者的公鑰，如果解密可以成功就代表是本人傳送的(因為私鑰只有本人有)。 訊息保密： 如果我們今天要傳遞訊息給特定的使用者A君，然後希望其他人都無法知道訊息的內容，則可以透過 PKI 取得 A君的公鑰，對訊息加密後進行傳輸，儘管訊息傳遞過程中間的人(比方説郵差)有經手這則訊息，但因為對應的私鑰只有A君本人有，所以郵差先生就無法解密而得知訊息的內容。 </description>
    </item>
    
    <item>
      <title>使用 indexedDB 離線儲存圖片</title>
      <link>https://yishiashia.github.io/posts/offline-image-storage-using-indexeddb/</link>
      <pubDate>Fri, 07 Oct 2022 15:51:22 +0800</pubDate>
      
      <guid>https://yishiashia.github.io/posts/offline-image-storage-using-indexeddb/</guid>
      <description>緣起 由於最近碰到要在負責的網頁式聊天機器人中，新增如同Line聊天室的貼圖功能，可想而知會有大量的貼圖圖片會需要在用戶裝置瀏覽器進行下載，不管是對圖片伺服器或是用戶等待的過程來說都是不小的負擔。
為了解決這個問題，透過使用了 PWA (Progressive Web App) 技術中常用的離線儲存方案 indexedDB 來快取貼圖圖片，不僅減少用戶端與網站伺服器端的連線流量，也提升的用戶體驗(UX: User Experience) 。
Photo by Scott Graham on Unsplash
Service Worker Service Worker是一個事件驅動的網站 Worker，根據不同的來源 (origin) 與網址路徑 (path) 進行註冊後，之後再次訪問同一網站後即會在背景執行這個 Service Worker。
Service Worker 無法直接存取 DOM 物件，他負責監聽和處理像是 fetch, notification(推播), sync 還有 Service Worker 註冊、啟動 等相關事件。
透過處理上述事件，我們可以讓 web 網頁像一般的手機原生 App 一樣可以執行安裝、發送推播、離線瀏覽及連線後同步等等作業。
離線儲存 常見的 Ｗeb 儲存方案有下面幾種:
Cookie LocalStorage Cache (precache) indexedDB 一般 SPA (Single Page Application) 中比較常用的是 Cookie 跟 LocalStorage 兩種儲存方法，不過在使用上都會有大小的限制（無法儲存較大的網站資源），像是 LocalStorage 的限制依照瀏覽器不同會落在大約 2MB ~ 10MB 左右，超過後就會發出Error。</description>
    </item>
    
    <item>
      <title>使用 CoreDNS 自建 DNS Server</title>
      <link>https://yishiashia.github.io/posts/self-hosted-dns-with-coredns/</link>
      <pubDate>Mon, 15 Aug 2022 15:25:41 +0800</pubDate>
      
      <guid>https://yishiashia.github.io/posts/self-hosted-dns-with-coredns/</guid>
      <description>這陣子在研究自行建設 Postfix Mail Server，發現要架設一個 Mail Server 沒有想像中的容易，除了需要透過 DNS 記錄設定網域的 A 記錄、 MX 記錄之外，另外需要 DNS 設定 SPF, DKIM, DMARC 等安全性設定。
在設定的過程中很快的遇到了瓶頸，一般的網域服務諸如 HiDomain、GoDaddy 等平台都有代管 DNS 記錄的上限，像我使用的 HiDomain 就有最多設定 20 筆記錄的上限，因為在不同專案已經註冊了許多子網域，這次要架設一個 Mail Server 時我很快就碰到了 DNS 記錄的代管上限，後來決定使用在 Kubernetes (k8s) 中經常使用的輕量 DNS Server CoreDNS 來自建 DNS Server。
Photo by Markus Winkler on Unsplash
關於 CoreDNS CoreDNS 是雲原生運算基金會 (Cloud Native Computing Foundation, 簡稱 CNCF)的一項專案，並於 2019 年畢業。
CoreDNS 主要使用 Go 語言實做，所以可以安裝於不同平台並且相當輕量不會佔用太多系統的資源，同時在設定上非常簡單，透過使用 corefile ，可以很簡單的引入各種 plugin，很大程度地減少設定上的複雜度，接下來就實際進入安裝與使用的介紹。
安裝 CoreDNS 官網上提供了三種安裝方式， Binaries 、 Source 及 Docker。</description>
    </item>
    
    <item>
      <title>使用 CSS Variables 切換前端主題(Theme)</title>
      <link>https://yishiashia.github.io/posts/switch-themes-with-css-variable/</link>
      <pubDate>Wed, 10 Aug 2022 14:36:11 +0800</pubDate>
      
      <guid>https://yishiashia.github.io/posts/switch-themes-with-css-variable/</guid>
      <description>Photo by Joanna Kosinska on Unsplash
前端專案時常需要進行主題(Theme)切換，比方說現在最常見的 light/dark mode 主題切換。
本文將介紹如何透過 CSS Variables (或 CSS Custom Properties) 及 HTML root element 上的屬性控制前端網頁的主題切換。
CSS Variables (或 CSS Custom Properties)是 CSS3 的新功能，讓您可以不用透過SASS、SCSS等預處理語言即可在原生 CSS 語法中使用變數，讓 CSS 語法也可以達到 Clean Code。
:root { --primary-color: blue; } p { color: var(--primary-color); } h1 { color: var(--primary-color); } ▲範例：透過 CSS Variable 指定主題色彩的顏色
上面是一個簡單的範例，透過一個 &amp;ndash;primary-color 的變數指定主題色彩，並套用到網頁中不同元的的樣式之中，未來要修改主題色時，只需要更新該變數，就可以一次性切換頁面中元件(如範例中的 與 標籤)的主題色，而不用一項一項的修改 CSS 樣式。
Theme 主題切換 從前面的說明中可以得知，宣告 Theme 相關的 CSS Variables 時通常會將變數的定義寫在 :root 的區塊中讓全域的 element 元件都可以取用，這意思就是說 CSS 變數需要定義在 document.</description>
    </item>
    
  </channel>
</rss>
